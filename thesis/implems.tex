\chapter{Building a decentralized social semantic Web}
\label{ch:implementations}
The Semantic Web is envisioned as a decentralised world-wide information space for sharing machine-readable data with a minimum of integration costs. Its two core challenges are the distributed modelling of the world with a shared data model, and the infrastructure where data and schemas can be published, found and used. Users benefit from getting information "raw and now" and in portable data formats, usually based on RDF, which can then be published on the Web. Others can read the data and publish their own information, linking to existing resources. This forms a distributed model of the world. It allows the user to pick any application to view and work with the same data, for example to see Ann's published address in your address book.\\

At the same time, documents on the Web have always been addressed with URIs (often referred to as Uniform Resource Locators, URLs). This is useful because it means that we can easily make RDF statements about Web pages, but it is also dangerous because we can easily mix up Web pages and the \textit{things}, or \textit{resources}, that are described on the page (cf. Section~\ref{subsec:webid_uri}).\\

A truly decentralized social Web application, based on Semantic Web technologies, requires several key components. It must be able to offer decentralized user identity, secure authentication, semantic data storage, to apply Create-Read-Update-Delete (CRUD) operations to resources, to offer increased privacy through access control, and most importantly, to be interoperable with other applications in terms of data exchange (e.g. content sharing, messaging, activity notifications, etc.).\\

This chapter intends to be a guide on how to proceed with building a decentralized social Web application. It also reflects our implementation efforts in the form of MyProfile, a decentralized identity platform, which serves as a demo for the theoretical solutions we have proposed in the previous chapters. We will explain our conceptual decisions as well as any technical limitations we ran into during the development of MyProfile.\\

\section{MyProfile}
The project \textit{MyProfile}~\cite{sambra2011myprofile} is a reflection of all efforts we have made over the course of this thesis. It intends to provide to users the privacy they deserve for the data they produce and own. It offers a unified user account, which centralizes the user's data and puts it under the user's control, and also on a device the user controls. It is a radical change from the \textit{walled gardens} of today's Web, where data are trapped in \textit{silos}.\\

The project was launched in April 2011, and it was funded entirely by TELECOM SudParis, member of group Institut Mines-TELECOM. It offers a unique identity platform, which takes advantage of Semantic Web technologies, so that users no longer need to invest time and effort into building complex profiles on the numerous websites/services they currently use. The profile is stored on a Web accessible device where only the user has access -- the user's computer, a dedicated server, or ideally a plug computer like the FreedomBox\footnote{http://www.freedomboxfoundation.org/}. This way, the user controls both the physical data and who can access it.

MyProfile also offers services that do not require a local profile. Any user is able to \textit{view} his/her profile data in a friendlier and attractive way. While viewing the profile data, the platform displays the user's list of known people (i.e. friends), some basic information for each friend (e.g. full name, nickname, email, blog), as well as a text mention in case the relationship is bidirectional (i.e. "Has you as friend.").\\

Once authenticated, additional functionalities become available. For example, users can post messages to a public \textit{wall}, which is a common place for all users to write about news, events, social updates, etc. Users can also \textit{subscribe} to local services in order to have their own private wall, which is only available to their list of known people. Subscribing also allows users to send and receive private messages, as well as notifications when other users have posted something on their private wall.\\

The source code for MyProfile has been released under an MIT license (less restrictive compared to other open source licenses), and it is publicly available on GitHub under MyProfile\footnote{https://github.com/MyProfile/myprofile}. For portability and deployment reasons, the platform was mainly written in PHP and JavaScript. It relies on Virtuoso\footnote{http://virtuoso.openlinksw.com/} to facilitate RDF-triple storage and SPARQL queries for cached profiles. A running demo of MyProfile can be accessed at https://my-profile.eu/.\\

Let us now take a detailed look at each platform component, starting with the user profiles.

\subsection{Creating a user profile}
MyProfile uses WebID as the main mechanism for user profiles, allowing for an increased interoperability. Depending on the user's social interactions on the Web, the profile could also extended to contain resources like blog and forum posts, or even mailing list messages, all described using dedicated ontologies. We can safely say that the user's profile can contain an unlimited number of resources, as long as they can be expressed using standard Semantic Web vocabularies.\\

The WebID URIs follow common Representational State Transfer (REST) structures. Each user is assigned a unique URI, composed of three main parts:
\begin{enumerate}
\item The server's IP address or fully qualified domain name (FQDN), i.e. \verb+https://my-profile.eu/+
\item The directory structure under which the profile is located, i.e \verb+people/barry/+ 
\item The profile document with a fragment identifier denoting the user, i.e. \verb+card#me+
\end{enumerate}

Finally, the complete WebID URI becomes the following:\\ 

\verb+https://my-profile.eu/people/barry/card#me+\\

The minimum information required for a new profile is comprised of the \textit{local username} (i.e. barry) and the user's full name, may it be real or not. Optionally, the user can provide an email address that will only be used for account recovery purposes, and is never disclosed to anyone else.

\subsubsection{Issuing client certificates}
During the account creation process, a client certificate will be issued and automatically installed in the browser, as well as have its public key added to the user profile. The system relies on HTML5 \textit{<keygen>} element, to guarantee that the private key is never disclosed, not even to the server. The \textit{keygen} element exists to facilitate generation of key material, and submission of the public key in the Signed Public Key and Challenge (SPKAC) \cite{ellison1999spki} format. The process is similar to generating Certification Signing Requests (CSRs), where an encoded public key can then be manipulated using OpenSSL\footnote{http://www.openssl.org/}.\\

The process of issuing the X.509~\cite{solo1999internet} client certificate has proven to be quite challenging. The main reason is due to how PKI works when it comes to signing CSRs, more specifically the dependence on a Certification Authority (CA). Basically, once the public key and the user's full name have been sent by the browser, the server must transform them into a valid CSR and sign them with the CA's key. The problem we ran into, while using PHP, was that there is no support for this kind of cryptographic operations. Therefore, we ended up using OpenSSL through a system call.\\

Another issue related to X.509 certificates concerns the way they are sent back to the client. Once the user submits the form containing the HTML5 \textit{keygen} element, the server must return the certificate by responding with the proper content type, set to \textit{application/x-x509-user-cert}. The problem lies in the fact that by setting a specific content type for sending the certificate, no other data can be sent along the certificate, meaning that the server cannot send a page to indicate the success of the operation. Unaware users may believe that no action was performed and they might click the submit button again.

\subsubsection{Publishing the profile}
MyProfile user profiles are expressed as Turtle~\cite{beckett2008turtle} documents by default, in order to align with the WebID specification. However, users have the option to export their profiles using different serialization formats, like RDF/XML~\cite{beckett2004rdf}, N3~\cite{berners2000primer} or JSON~\cite{crockford2006application}.\\

When a request for the profile document arrives, the Web server must decide which content type to serve. Currently, MyProfile uses \textit{.htaccess} files to intercept requests and perform content negotiation based on two content types, \textit{text/turtle} and \textit{text/html}.\\

\begin{example}[h]
\begin{minted}{apache}
Options -MultiViews -Indexes
AddType "text/turtle" .ttl
RewriteEngine On
RewriteBase /people/barry/
RewriteCond %{HTTP_ACCEPT} !text/turtle
RewriteRule ^card$ https://my-profile.eu/view?webid=<WebID> [R=303]
RewriteCond %{HTTP_ACCEPT} text/turtle
RewriteRule ^card$ card.ttl [L]
\end{minted}
\caption{Contents of a .htaccess file for user profiles.}
\label{ex:htaccess}
\end{example}

Example~\ref{ex:htaccess} displays the contents of a .htaccess file, for user \textit{barry}. Here we have two conditions, expressed using the \textit{RewriteCond} directive. The first condition states that if the Accept header of the request is different from \textit{text/turtle}, then it will serve HTML by triggering the \textit{RewriteRule} that redirects the user to the special view page. On the other hand, if the Accept header is explicitly set to \textit{text/turtle}, it will serve the RDF document instead (i.e. card.ttl).

\subsection{Viewing profiles}
MyProfile provides a visually appealing rendering of WebID profiles, regardless if the user is local or not (Figure~\ref{fig:view_html}). To read and process RDF data, we have decided to use EasyRdf, a PHP library designed to make it easy to consume and produce RDF as graph of PHP objects that can then be walked around to get the data to be placed on the page.\\

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=350px]{img/screens/view_html.jpg}
        \caption{Rendering of a profile.}
        \label{fig:view_html}
  \end{center}
\end{figure}

The view page provides additional information for the user's known people, in the form of full name, nickname, email, phone number and blog. If the user is authenticated and viewing his/her own profile, a text mention "Has you as friend." will appear next to the known person if that person also has a \textit{foaf:knows} relation pointing back (Figure~\ref{fig:view_html}). Additionally, the view page offers a series of buttons that allow to quickly remove known people from the user's profile, to view their wall and even to explore their social graph, as seen in Figure~\ref{fig:view_html}.\\

The same page allows users to lookup other people by searching for names, nicknames and WebID URIs within the cached public profiles of people that have used the platform at one point or the other. If the user performing the lookup is authenticated and has a local profile, he/she can then simply press a button to add one or more search results to his/her list of known people.

\subsection{Social walls and activity streams}
The \textit{social wall} is a familiar concept in social networks. It allows users to post updates about their life, to talk about their interests, to share links and content, or to openly communicate with other people (Figure~\ref{fig:public_wall}).\\

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=350px]{img/screens/public_wall.jpg}
        \caption{MyProfile public wall.}
        \label{fig:public_wall}
  \end{center}
\end{figure}

MyProfile offers two types of social walls. The first type is a platform-wide, shared public wall. Its purpose is to allow users to quickly post public information, that may also be of use to people outside their friends list. To be able to post on the public wall, users need to be authenticated through WebID-TLS (see Section~\ref{sec:webid-auth}). The second type is a private, restricted access wall, which is only available to the user's known people (i.e. described through \textit{foaf:knows} relations). Other people can express their level of appreciation towards wall posts by either liking or disliking them.\\

The activity stream is a derivative of the social wall. It is a collection of all posts written by people the user knows, and presented in a chronological order. Its purpose is to allow users to keep track of updates from their friends, without having to visit the private walls of their friends.\\

Based on the content type of the \textit{Accept}, clients can request either an HTML view of the social wall, or more importantly, an RDF view. Currently, only Turtle and RDF/XML serialisation are available for the RDF view. Wall posts are represented using the SIOC~\cite{breslin2005towards} ontology. Example~\ref{ex:wall_paging} displays how pagination is supported through URI requests, though it does not reflect in the RDF data.

\begin{example}[h]
\begin{minted}{c}
GET /wall.php?offset=20 HTTP/1.1
Host: my-profile.eu
Accept: text/turtle
\end{minted}
\caption{RDF social wall pagination.}
\label{ex:wall_paging}
\end{example}

\subsection{Account recovery and pairing}

\subsubsection{Account recovery}
Since MyProfile uses WebID-TLS for authentication, if a user cannot use his/her certificate any longer and regardless of the reason, there must exist the possibility to recover access to his/her account. Account recovery will work only if the user has already provided an email address for this purpose, either at the moment of creating the WebID, or through the preferences page.\\

The first step of the procedure to recover access to a MyProfile account involves providing the user's WebID. Once this information is submitted, the system will generate a one-time password (OTP)~\cite{haller1995s} in the form of a hash (i.e. a string of alphanumeric characters) and bind it to the WebID submitted by the user. Finally, an email is sent to the address initially specified by the user when he/she created the account. The email contains a pre-formatted link containing the OTP, which enables the user to authenticate as if he/she was authenticating through WebID-TLS. Once authenticated, the user has the possibility to issue new certificates, which will be automatically added to his/her WebID profile. If the authentication was successful, the OTP is removed so it can never be used again to gain access to this particular account.

\subsubsection{Pairing}
The pairing process was created to address the difficulty of having to manage client certificates across different browsers and devices. Until now, users had to manually export certificates from one browser and then import them into a different browser or device. The pairing process is different from account recovery, though it can be used to provide a similar end result.\\

In this case, users must first authenticate (either through WebID-TLS or by using the account recovery feature) in order to access their preferences page. This page allows them to generate a 6 digit one-time numeric password, which we call \textit{PIN} (Figure~\ref{fig:pairing_pin}). To avoid brute-force attacks on the PIN, we have decide to limit its validity period to one minute, starting from the moment it was issued. A new PIN must be generated if the user is not able to type it within the given time frame on the other device.\\

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=350px]{img/screens/pin_gen.jpg}
        \caption{Generating a pairing PIN.}
        \label{fig:pairing_pin}
  \end{center}
\end{figure}

\subsection{Statistics}
MyProfile is currently the de facto service provider when it comes to issuing WebIDs, hosting close to 500 WebIDs, and being visited daily by more than 30 different users. It is also the main reference when it comes to implementing a decentralized social Web application.\\

MyProfile has been the subject in different workshops and conferences around the world, as well as in different talks and presentations in the past two years:

\begin{itemize}
\item 2013: Mentioned in "Let's tear down these walls" talk at SIGINT13\footnote{https://sigint.ccc.de/} in Cologne (Germany), an annual hacker conference covering both technical and social aspects of our digital society.

\item 2013: Mentioned at OuiShare Fest\footnote{http://ouisharefest.com/} in Paris, a conference about the collaborative economy in Europe.

\item 2012: Included by the Free Software Foundation Europe\footnote{http://fsfe.org/} in their list of different approaches for Cloud Computing. The development of MyProfile is also followed by the FreedomBox Foundation\footnote{http://www.freedomboxfoundation.org/}.

\item 2011: Presented by me in a panel called "Alternatives to Facebook" during the Social Media Week Berlin\footnote{http://socialmediaweek.org/berlin/} event.

\item 2011: Mentioned in Heise\footnote{http://www.heise.de/}, a respectable German online news magazine.
\end{itemize}


\section{WebID authentication}
WebID-TLS authentication plays a crucial role in MyProfile. On one hand it allows any authenticated user to post messages on walls or contact other people, regardless if they have a local account or not. On the other hand, local users that have been authenticated can also easily update their profiles, issue new certificates or manage their friends.\\

There exists two different WebID-TLS authentication approaches, either perform the WebID-TLS verification locally, or use a third party WebID-TLS authentication service. We have developed two libraries, written in PHP, which cover both approaches. The libraries have been released under the MIT license, and are publicly available on GitHub under WebIDauth\footnote{https://github.com/organizations/WebIDauth}. In the following subsections we will describe both libraries, as well as how the Web server must be configured to offer WebID-TLS authentication. 

\subsection{Configuring the Web server}
WebID-TLS authentication requires the Web server to be configured in a special way. For portability and deployment reasons, we have decided to use the Apache~2 Web server\footnote{https://httpd.apache.org/}.\\

To request client certificates from users, the Web server configuration file must include the following directives:
\begin{itemize}
\item \verb+SSLVerifyClient optional_no_ca+ -- skip verifying the CA, since WebID does not operate based on standard PKI trust
\item \verb+SSLVerifyDepth 1+ -- stop after the initial certificate, to avoid recursively traversing the trust chain
\item \verb!SSLOptions +ExportCertData! -- export certificate contents to the environment, so that it can be used by other programs (e.g. PHP, Python, Java, etc.)
\end{itemize}

The above directives must be part of the \textit{VirtualHost} configuration, as it is no longer possible to place them in \textit{.htaccess} files due to security issues. A full example of the Apache configuration file is provided in the Appendix, under Example~\ref{app:auth_conf}.\\

Please note that in order to allow old browser versions that do not support SSL renegotiation, the following configuration directive must be present:\\

\verb+SSLInsecureRenegotiation on+

However, if this directive is enabled, SSL connections will be vulnerable to the Man-in-the-Middle prefix attack\footnote{http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2009-3555}.

\subsection{WebIDauth}
Local authentication can be achieved by relying on \textit{WebIDauth}, a PHP library implementing WebID-TLS. Its particularity resides in the fact that it allows users to request a \textit{verbose} authentication process, which is useful when debugging a faulty certificate or a user profile.\\

WebIDauth can operate in two modes. In the first mode, its task is to perform WebID-TLS authentication and simply return either \textit{true} or \textit{false}, depending whether the user was successfully authenticated or not. This mode is intended to be used as an authentication method for a local application, usually coupled with a user session. However, operating in this mode also implies configuring the Web server to run over HTTPS, adding to the expenses of hosting the local application by having to buy a server certificate.\\

In the second operation mode, WebIDauth can be used as a Relying Party, a third-party service that provides a WebID-TLS authentication endpoint for Web applications that cannot perform the authentication process themselves. There are several advantages to using a Relying Party service. For instance, it drastically reduces the complexity of having to set up the Web server to allow WebID-TLS authentication. Additionally, the service provider (local application) may not require HTTPS, therefore the owners do not need to pay for a server certificate. We will present in detail how this process is accomplished in the next subsection that deals with delegated authentication.\\

Currently, WebIDauth supports the following functionalities:
\begin{itemize}
\item It initiates the WebID-TLS protocol, by requesting a client certificate from connecting users
\item It checks if the SubjectAltName field contains something else other than the WebID URI, and only processes HTTP URIs
\item It checks if the WebID profile document contains any public keys of type \textit{RSApublickey} and cycles through them looking for a possible match
\item It checks the HTTP request for a variable called \textit{verbose} and if it is set, it displays the contents of the certificate used to connect to the IdP, as well as each step of the WebID-TLS protocol
\end{itemize}

WebIDauth is actively being used for over two years to offer a WebID-TLS authentication service, located at https://auth.my-profile.eu/. Several people have contributed to the source code of this library, improving it in multiple ways. Lately, the service offered by https://auth.my-profile.eu/ handles an average of 2000 authentication requests per month, while in the past year alone it has been accessed by more than 4500 users around the world.

\subsection{WebIDDelegatedAuth}
Delegated WebID-TLS authentication is the process of relying on a third-party service to perform the authentication, and then redirect the user back to the Service Provider, as seen Section~\ref{sec:webid-tls_delegated_auth}. This is currently the default operation mode for MyProfile. The WebIDDelegatedAuth library was created so that Service Providers can offer WebID-TLS authentication in case they are not capable of offering local authentication, or they do not operate over HTTPS. Let us now explore each step of the process.\\

First, the user clicks a login button on the Service Provider (i.e. https://my-profile.eu) and is redirected to the Relying Party (i.e. https://auth.my-profile.eu), thus triggering the authentication process. The Service Provider also appends a variable to the redirection URI, containing the Service Provider's URI:\\ 
\textit{https://auth.my-profile.eu/?authreqissuer=https://my-profile.eu}.\\

Next, the Relying Party uses WebIDauth to perform WebID-TLS authentication. If the user has been successfully authenticated, the Relying Party prepares the redirection request, appending additional arguments to the redirection URI, namely the \textit{webid}, \textit{ts}, \textit{referrer} and \textit{sig}.\\

The aforementioned arguments have the following meanings, as we have seen in Section~\ref{sec:webid-tls_delegated_auth}:

\begin{itemize}
\item \verb+webid+ - https://my-profile.eu/people/barry/card\#me.
\item \verb+ts+ - 2013-05-22CEST16\%3A54\%3A04\%2B02\%3A00
\item \verb+referrer+ - https://auth.my-profile.eu
\item \verb+sig+ - hR5cv9gPn.....MxBbSdq7f.
\end{itemize}

Back on the Service Provider, WebIDDelegatedAuth is used to verify the incoming request, by attempting to find the referrer's public key among a local list of trusted Relying Party URIs. Once the signature and the timestamp have been validated, the Service Provider proceeds to login the WebID \textit{https://my-profile.eu/people/barry/card\#me} belonging to the user. To avoid repeating the process, a session is created and a cookie with a validity period of 24 hours is issued to the user.\\

If you would like to find out how to quickly deploy WebIDDelegatedAuth to enable a Service Provider to offer WebID-TLS authentication for its users, please see Example~\ref{app:webiddelegatedauth} of the Appendix.

\section{Static Access Control}
\label{sec:sac_implem}
The SAC library is used to offer a \textit{unique view} of a user's profile, based on the level of access specific for the agent requesting the information. It uses context labels to match users to the resources to which they are granted access. The same label must be assigned to the resource that is part of the user's profile (e.g. email address, phone number, etc.). As you can notice in Figure~\ref{fig:sac_ui}, users that are displayed as \textit{foaf:knows} relations can be considered both as normal resources to be protected (the icon with the eye), as well as users we want to match against the resources (the person shaped icon).\\

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=270px]{img/screens/sac_ui.jpg}
        \caption{Static Access Control icons displayed when viewing a profile.}
        \label{fig:sac_ui}
  \end{center}
\end{figure}

The library depends on Virtuoso to store graphs containing access control policies. The SPARQL language is used to insert data as well as to query the graphs. The source code is part of MyProfile Project, as the library is intended to be a core component of the platform.

\section{Personal data stores using RWW.I/O}
Offering individual data stores is an important aspect of any decentralized social application, as users must be allowed to choose where they want to host their data, as well as to have complete control over the privacy settings that apply to these data. If possible, data stores should be hosted by devices to which the user has physical access. However, for performance reasons, data stores may be located on third party servers, if users are not concerned by privacy issues.\\

Being invited to work with Sir Tim Berners-Lee on access control for the Semantic Web at the Massachusetts Institute of Technology, has allowed me to develop a Linked Data personal data store platform that implements the Web Access Control~\cite{hollenbach2009using} (WAC) ontology. The code is written in PHP, Python and JavaScript, and is publicly available under an MIT license on Github at \textbf{RWW.io}\footnote{https://github.com/deiu/rww.io}.\\

RWW.I/O stands for \textit{Read-Write-Web Input/Output} and it operates under the assumption that users require a personal data store, where different applications can store data about and for the user, and where data are equally available between applications (Figure~\ref{fig:rww}). The advantage is that different applications can reuse the same data, to offer different functionalities. For example, a contact management application can pull data from the user's profile and modify it at the user's request. The modifications are instantly reflected in the user's profile the next time someone accesses the profile.\\

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=350px]{img/screens/rww.jpg}
        \caption{The RWW.I/O service.}
        \label{fig:rww}
  \end{center}
\end{figure}

\subsection{Creating data stores}
To create their personal data store, users must first choose a desired location for their data. Location is determined based on a unique string of characters defined by the user, similar to an account name, which is then transformed into a subdomain. In other words, the account name \textit{deiu} is used to create the subdomain \verb+https://deiu.rww.io/+, which in turn becomes the user's personal data store. Users can have an unlimited number of data stores, regardless of where they are located.\\

Creating the data store implies only setting up the subdomain. To own the data store, users must first authenticate using WebID-TLS and then claim the subdomain by creating an access control rule for the root directory (i.e. the subdomain itself). This step can be done either through the access control UI, or directly by performing an HTTP POST of a Turtle document containing the ACL triples. If users do not have a WebID, they can create a minimal one locally, and then use it to authenticate and claim ownership of the data store.\\

The platform supports full Create-Read-Update-Delete (CRUD) operations, following the REST standards. Documents and directories can be created by performing HTTP requests such as POST, PUT and MKCOL (i.e. new directories), following the requirements we presented at the beginning of the chapter. The \textit{Content-Type} HTTP header plays a central role to interpreting the requests and deciding whether to store data as triples or as binary files. As RWW.I/O is not intended to be a fully-fledged cloud service, only a handful of content types are supported.\\

In order to detect a conflict when overwriting a resource through HTTP PUT, we are using HTTP/1.1 features including entity tags (ETags)~\cite{nielsen1999editing}, the various If-* preconditions header field (e.g. \verb+If-Match+, \verb+If-None-Match+, etc.) and HEAD requests.

\subsection{Managing access control for resources}
Access control rules for the data store resources are specified using the Web Access Control ontology. The data store was designed to use one ACL file for each document, thus separating the metadata containing the access control rules from the document they protect. The naming convention for the metadata files involves using a \verb+.meta+ prefix before the filename. For example, if a given file is named \textit{photo.jpg}, the corresponding metadata file will be named \textit{.meta.photo.jpg}, and it will be situated at the same directory level. Assigning an ACL metadata file for each document offers the advantage of flexible access control management, especially for resources for which control is handled by third party users or even applications (i.e. a data store within a data store).\\

Managing access control rules can be achieved either through an ACL user interface (UI), or by manipulating the metadata files through HTTP verbs (i.e. POST, PUT, DELETE). The UI offers minimal functionalities, as seen in Figure~\ref{fig:acl_ui}. If the \textit{Default} checkbox is enabled and the resource is a directory, the rules will apply by default for all resources in that specific directory. The default rules can be superseded later on by creating metadata files for those resources.\\

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=250px]{img/screens/acl_ui.jpg}
        \caption{ACL user interface.}
        \label{fig:acl_ui}
  \end{center}
\end{figure}

To conform to the best practices of using the Web, the UI also uses HTTP verbs to create and modify metadata files. This way, users are able to create workspaces (i.e. dedicated data stores) for third-party applications, which enable the applications to handle their own ACL management, regardless of who owns the data store. Example~\ref{ex:metafile_profile} describes the process of creating a metafile for a WebID protected document.\\

\begin{example}[h]
\begin{minted}{c}
PUT /private/protected.ttl HTTP/1.1
Host: deiu.rww.io
Content-Type: text/turtle
Content-Length:407

Payload:
\end{minted}
\begin{minted}{turtle}
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix WAC: <http://www.w3.org/ns/auth/acl#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/#> .
<>
    WAC:accessTo <> ;
    WAC:agent <https://my-profile.eu/people/deiu/card#me> ;
    WAC:mode <WAC:Read>, <WAC:Write> .

<#protected.ttl>
    WAC:accessTo <protected.ttl> ;
    WAC:agent <https://my-profile.eu/people/deiu/card#me> ;
    WAC:mode <WAC:Read>, <WAC:Write> .
\end{minted}
\caption{Creating a metafile for the document \textit{/private/protected.ttl}.}
\label{ex:metafile_profile}
\end{example}

Creating a metafile for \verb+/private/protected.ttl+ implies creating two access control rules. The first rule, <>, applies to the document itself (i.e. https://deiu.rww.io/private/.meta.protected.ttl), and it states that only the agent identified by the WebID \textit{https://my-profile.eu/people/deiu/card\#me} is allowed to perform \textit{Read} and \textit{Write} operations on the document in question. The second rule is for the document the metafile protects (i.e. \verb+/private/protected.ttl+). The rule states that the Read and Write operations are allowed for the agent identified by the WebID URI.

\subsection{Application workspaces - a complete example}
This section will provide a complete example, explaining how users can create dedicated workspaces for third-party applications, in this case a photo viewing application. We assume that Barry uses RWW.I/O as a personal data store, located at \textit{https://barry.rww.io/}.\\

\subsubsection{Step 1}
At some point, Barry decides that he wants to use a photo viewing service, namely "myPhotos". To begin using this service, Barry must first login into https://myphotos.com with his WebID. Once authenticated, myPhotos creates a unique resource, containing a list of required data store permissions corresponding to several functionalities it can offer, which then binds to Barry's WebID. The permissions resource is available for Barry to inspect at http://myphotos.com/permissions/<sha1> (Example~\ref{ex:myphotos_permissions}).\\

\begin{example}[h]
\begin{minted}{turtle}
@prefix wapp: <http://ns.rww.io/wapp#> .
<>
    wapp:redirects <https://myphotos.com> ;
    wapp:permission <#a> ;
    wapp:permission <#b> ;
    wapp:permission <#c> ;
    wapp:permission <#d> .
<#a>
    wapp:kind wapp:mandatory ;
    wapp:requires wapp:workspace ;
    wapp:requires wapp:read ;
    wapp:requires wapp:write ;
    wapp:usage <http://dbpedia.org/Photo> ;
    wapp:suggestedName "photos" .
<#b>
    wapp:kind wapp:mandatory ;
    wapp:requires wapp:workspace ;
    wapp:requires wapp:exclusive ;
    wapp:suggestedName "myphotos" ;
    wapp:description "Photo viewing application." .
<#c>
    wapp:kind ws:optional ;
    wapp:advertiseInProfile [
        wapp:comment "myPhoto is cool!"
    ] .
<#d>
    wapp:kind ws:functional ;
    wapp:requires wapp:workspace ;
    wapp:requires wapp:read ;
    wapp:requires wapp:write ;
    wapp:usage <http://dbpedia.org/Tag> ;
    wapp:suggestedName "tags" .
\end{minted}
\caption{List of permissions required by the application \textit{myPhoto}.}
\label{ex:myphotos_permissions}
\end{example}

\subsubsection{Step 2}
After the registration process (and perhaps payment), myPhotos redirects the user to his/her personal data store service, while also passing the permission resource as an HTTP request parameter: https://barry.rww.io/permissions?permissions=<url encoding of http://myphotos.com/permissions/<sha1> >.\\

Barry's data store service fetches the permission resource from myPhotos, and then generates a form so that each permission can be accepted or rejected by the user. If all \textit{mandatory} permissions are accepted, the data store service can process and update the permissions resource with the user approvals and rejections. Since in this case Barry has decided that he does not want to add the third permission (i.e. <\#c> -- which would add and advertisement comment to his profile), so it will be removed from the list of permissions.\\

Additionally, based on the \textit{wapp:usage} specified in the permissions list, the data store service will assign specific workspace URIs for each accepted permission (Example~\ref{ex:barry_updated_permissions}). Once the permissions list has been updated, the data store service will POST the updated permissions list containing the triples in Example~\ref{ex:barry_updated_permissions}, to myPhoto:

\begin{example}[h]
\begin{minted}{console}
Command:

curl -X POST \textbackslash
     -H "Content-Type: text/turtle" \textbackslash
     -E rww.io-cert.pem \textbackslash
     -d @updated-permissions.ttl \textbackslash
     https://myphotos.com/permissions/<sha1> 

Contents of updated-permissions.ttl:
\end{minted}
\begin{minted}{turtle}
@prefix wapp: <http://ns.rww.io/wapp#> .
<#a> wapp:status ws:Accepted ;
    wapp:workspace <https://barry.rww.io/photos/> .

<#b> ws:status ws:Accepted ;
    wapp:workspace <https://barry.rww.io/apps/myphotos/> .

<#c> ws:status ws:Rejected .

<#d> ws:status ws:Accepted ;
    wapp:workspace <https://barry.rww.io/tags/> .
\end{minted}
\caption{Returning the list of updated permissions.}
\label{ex:barry_updated_permissions}
\end{example}

\subsubsection{Step 3}
After having accepted the permissions, a trust relation must be created between myPhoto's Web agent (i.e. http://myphotos.com/profile\#agent) and Barry. The trust relationship is very important, as it allows the application to act on his behalf (Section~\ref{sec:webid-delegated-access}) while manipulating resources on Barry's data store.\\

\begin{example}[h]
\begin{minted}{turtle}
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix wapp: <http://ns.rww.io/wapp#> .

<>
    a foaf:PersonalProfileDocument ;
    foaf:primaryTopic <#me> .

<#me>
    a foaf:Person ;
    foaf:name "Barry" ;
    wapp:uses <#myphotos> .

<#myphotos> 
    a wapp:app ;
    wapp:service <https://myphotos.com/> ;
    wapp:endpoint <https://barry.rww.io/apps/myphotos/> ;
    wapp:description "Photo viewing application." ;
    foaf:agent <https://myphotos.com/profile#agent> .
\end{minted}
\caption{Updated profile for Barry.}
\label{ex:barry_updated_profile}
\end{example}

Example~\ref{ex:barry_updated_profile} contains the triples that have been added by the data store service to Barry's profile, to indicate that Barry uses the Web application \textit{myPhotos}. For each application Barry installs on his personal data store, several metadata entries will be added to his profile. This method enables other users to discover interesting applications, by looking at what applications people are using.\\

We believe this is a suitable example that helps to showcase the viability of a decentralized system in which identity, authentication, data storage and service providers are never located on the same system. Web Applications (wapp) is a work in progress ontology that aims to provide a starting point for describing Web applications and how they operate. The wapp document is publicly available\footnote{http://ns.rww.io/wapp\#} and can be improved by anyone simply by adding more relations.

\section{Conclusions}
One of the requirements imposed by W3C with regard to WebID and WebID-TLS, was to create working implementations that would allow people to test the protocols in a real world scenario. For this matter, implementing MyProfile has been a challenge both at a conceptual and at a technical level, as it involved working with several new concepts, like decentralized identity and authentication, generating and consuming linked data, and even user interface ergonomics.\\

Regarding our choice of technologies, we decided to use PHP and Python as the preferred programming languages, as they are widely supported and not demanding in terms of computational resources. MySQL was only used for MyProfile, to store information specific to the platform's inner functionalities (e.g. account recovery and pairing, private wall identifiers corresponding to specific users, etc.), and for the same reasons as the ones mentioned earlier for PHP. Generating and consuming linked data was handled by a dedicated third party library called \textit{EasyRdf}\footnote{https://github.com/njh/easyrdf}, which is also written in PHP. Storing semantic data was done through OpenVirtuoso\footnote{http://virtuoso.openlinksw.com/}, a database that is optimized for the storage and retrieval of RDF triples using the SPARQL protocol. As opposed to MyProfile and WebID authentication libraries, RWW.I/O uses \textit{librdf}\footnote{http://librdf.org/} for linked data manipulation, as it is reputed to be very fast, scalable and with a low impact on computational resources; characteristics that are vital for a "cloud"-like service.\\

Most problems we encountered were related to using older browser versions (especially Internet Explorer) when issuing WebID client certificates or when performing WebID-TLS authentication, due to the Web server having to be specially configured. In the end, we have opted against supporting Internet Explorer versions older than IE8.\\

Overall, our implementations were well received by the community, and are currently used as the main references for WebID and WebID-TLS, as well as for personal user storage. They are also mentioned by other people in their videos and talks: SIGINT13\footnote{http://youtu.be/kAQsCoaOXAA}, WebID home page\footnote{http://webid.info/}, Crypto Stick\footnote{http://bblfish.net/blog/2011/05/25/cryptostick.mp4}, WebID in Drupal\footnote{http://vimeo.com/56960183}.\\

Alternative implementations are offered by OpenLink Software\footnote{http://web.ods.openlinksw.com/}, though they do not respect the same principles we defined at the beginning of this thesis, with respect to creating and using a single account.
